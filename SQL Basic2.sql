use ch2;
-- 실습 데이터 DEPT, EMP, SALGRADE
CREATE TABLE DEPT (
    DEPTNO DECIMAL(2),
    DNAME VARCHAR(14),
    LOC VARCHAR(13),
    CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO) 
);
CREATE TABLE EMP (
    EMPNO DECIMAL(4),
    ENAME VARCHAR(10),
    JOB VARCHAR(9),
    MGR DECIMAL(4),
    HIREDATE DATE,
    SAL DECIMAL(7,2),
    COMM DECIMAL(7,2),
    DEPTNO DECIMAL(2),
    CONSTRAINT PK_EMP PRIMARY KEY (EMPNO),
    CONSTRAINT FK_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES DEPT(DEPTNO)
);
CREATE TABLE SALGRADE ( 
    GRADE TINYINT,
    LOSAL SMALLINT,
    HISAL SMALLINT 
);
INSERT INTO DEPT VALUES (10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES (30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES (40,'OPERATIONS','BOSTON');
INSERT INTO EMP VALUES (7369,'SMITH','CLERK',7902,STR_TO_DATE('17-12-1980','%d-%m-%Y'),800,NULL,20);
INSERT INTO EMP VALUES (7499,'ALLEN','SALESMAN',7698,STR_TO_DATE('20-2-1981','%d-%m-%Y'),1600,300,30);
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,STR_TO_DATE('22-2-1981','%d-%m-%Y'),1250,500,30);
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,STR_TO_DATE('2-4-1981','%d-%m-%Y'),2975,NULL,20);
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN',7698,STR_TO_DATE('28-9-1981','%d-%m-%Y'),1250,1400,30);
INSERT INTO EMP VALUES (7698,'BLAKE','MANAGER',7839,STR_TO_DATE('1-5-1981','%d-%m-%Y'),2850,NULL,30);
INSERT INTO EMP VALUES (7782,'CLARK','MANAGER',7839,STR_TO_DATE('9-6-1981','%d-%m-%Y'),2450,NULL,10);
INSERT INTO EMP VALUES (7788,'SCOTT','ANALYST',7566,STR_TO_DATE('13-7-1987','%d-%m-%Y')-85,3000,NULL,20);
INSERT INTO EMP VALUES (7839,'KING','PRESIDENT',NULL,STR_TO_DATE('17-11-1981','%d-%m-%Y'),5000,NULL,10);
INSERT INTO EMP VALUES (7844,'TURNER','SALESMAN',7698,STR_TO_DATE('8-9-1981','%d-%m-%Y'),1500,0,30);
INSERT INTO EMP VALUES (7876,'ADAMS','CLERK',7788,STR_TO_DATE('13-7-1987', '%d-%m-%Y'),1100,NULL,20);
INSERT INTO EMP VALUES (7900,'JAMES','CLERK',7698,STR_TO_DATE('3-12-1981','%d-%m-%Y'),950,NULL,30);
INSERT INTO EMP VALUES (7902,'FORD','ANALYST',7566,STR_TO_DATE('3-12-1981','%d-%m-%Y'),3000,NULL,20);
INSERT INTO EMP VALUES (7934,'MILLER','CLERK',7782,STR_TO_DATE('23-1-1982','%d-%m-%Y'),1300,NULL,10);
INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,9999);
COMMIT;


DESC ch2.DEPT;
DESC ch2.EMP;
DESC SALGRADE;  -- db명을 안 선택한 경우에는 오류 날 수 있음.

SELECT * FROM DEPT;

SELECT DISTINCT JOB FROM EMP; -- 대표값만 보여줌

SELECT COUNT(EMPNO) FROM EMP; -- 키(EMPNO)의 갯수

SELECT * FROM EMP WHERE DEPTNO = 10;  -- 조건절, WHERE 조건에 대한 값 명시

SELECT * FROM EMP WHERE SAL >= 2500;  -- 월 급여가 2500이상인 사원 조회

SELECT * FROM EMP WHERE ENAME = 'KING'; -- 이름이 KING인 사원 조회,  패턴검색 %와 _차이 구분, 키워드와 식별자, 데이터는 대소문자 구별

SELECT EMPNO,ENAME FROM EMP WHERE ENAME LIKE 'S%'; -- 사원들 중 이름이 S로 시작하는 사원의 사원번호와 이름 조회

SELECT EMPNO, ENAME, COMM FROM EMP WHERE COMM = 300 OR COMM = 500 OR COMM = 1400;
SELECT EMPNO, ENAME, COMM FROM EMP WHERE COMM IN (300, 500, 1400);  -- SQL에는 IN 연산자가 있다. OR과 같은 역할

SELECT EMPNO, ENAME, COMM FROM EMP WHERE SAL BETWEEN 1200 AND 3500; -- BETWEEN,  1200LOW VALUE와 3500VALUE가 포함 된다.
SELECT EMPNO, ENAME, COMM FROM EMP WHERE SAL NOT BETWEEN 1200 AND 3500; -- 1200 미만, 3500초과

SELECT ENAME, EMPNO, JOB, DEPTNO FROM EMP WHERE DEPTNO = 30 AND JOB ='MANAGER'; -- 숫자, '문자' 자료형 구별, VARCHAR인 경우 ''있어야 함

SELECT ENAME, EMPNO, JOB, DEPTNO FROM EMP WHERE NOT DEPTNO = 30;
SELECT ENAME, EMPNO, JOB, DEPTNO FROM EMP WHERE DEPTNO != 30;

SELECT EMPNO, ENAME FROM EMP WHERE ENAME NOT LIKE '%S%';

SELECT ENAME, JOB FROM EMP WHERE MGR IS NULL;
-- GROUP BY
SELECT DEPTNO, AVG(SAL) AS'평균 급여' FROM EMP GROUP BY DEPTNO ORDER BY 1 ASC; -- 부서별 평균 월 급여를 구하라, 2번 컬럼을 순서대로 정렬, AS넣으면 출력시 칼럼 이름 바뀜
SELECT DEPTNO, COUNT(*), COUNT(COMM) FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, MAX(SAL), MIN(SAL) FROM EMP GROUP BY DEPTNO;
-- HAVING은 조건절, GROUP BY에 대한 조건절
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO HAVING AVG(SAL) >= 2000;

SELECT DEPTNO, AVG(SAL)		
FROM EMP					
WHERE SAL >= 1000		-- 월 급여가 1000이상인 사원을 대상으로
GROUP BY DEPTNO			-- 부서별로 월급여 평균을 구하라(2000이상만)
HAVING AVG(SAL) >= 2000;

SELECT ENPNO, ENAME, SAL
FROM ENP
ORDER BY SAL DESC, ENAME ASC;	-- 급여가 높은 순 조회, 급여가 같을 경우 이름 빠른 순

-- JOIN
-- 1번 사실상 의미없다		INNER JOIN : 두 테이블의 교집합
SELECT ENAME, DNAME		-- 사원명, 부서명
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;  -- 조인 조건
-- 2번 ALIAS 활용, 많이 쓰임
SELECT E.ENAME, D.DNAME		-- 사원명, 부서명
FROM EMP E, DEPT D			-- ALIAS 활용
WHERE E.DEPTNO = D.DEPTNO;  -- 조인 조건
-- 3번 STANDARD한 FORM 이다.
SELECT E.ENAME, M.ENAME
FROM EMP E 
JOIN EMP M   		--  INNER JOIN해도 되고, JOIN 해도 된다
ON E.MGR = M.EMPNO;

-- 관계형 DATABASE
-- 두 테이블에서 같은 값을 가져야 한다
-- COLUMN명은 다를 순 있지만 값의 종류, 값은 같아야 한다.
-- 기본키 PRIMARY KEY, 외래키 FOREIGN KEY로 관계를 맺는다. 보통 일대다 관계라고 합니다.
-- 조인할때는 ALIAS 쓴다. 조인 시에 조인 조건이 필요.

SELECT E.ENAME, M.ENAME		--  직속 상사 조사
FROM EMP E, EMP M 			-- ALIAS만 다르게
WHERE E.MGR = M.EMPNO;		
-- LEFT JOIN		
SELECT E.ENAME, D.DNAME		-- 이름 ,부서명을 조회하시오. 단 , 사원테이블에 부서번호가 40에 속한 사원이 없지만 부서번호 40인 부서명도 출력되도록 하시오
FROM DEPT D 
LEFT JOIN EMP E 		-- LEFT 생략가능
ON D.DEPTNO = E.DEPTNO;	-- INNER JOIN과의 차이점 : NULL 값을 가진 것이 들어온다

SELECT E.ENAME, D.DNAME
FROM DEPT D 
INNER JOIN EMP E
ON D.DEPTNO = E.DEPTNO;

SELECT ENAME, COMM, DNAME, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO - DEPT.DEPTNO		-- JOIN조건
AND EMP.COMM IS NOT NULL AND EMP.COMM <> 0;

-- SERVE QUERY
-- 서브 쿼리 해석해서 메인에 적용
SELECT DNAME		-- 'JONES'가 속한 부서명 조회하시오
FROM DEPT
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'JONES');

SELECT EMPNO, ENAME, SAL		-- 평군 월급여 보다 더 많은 월급여를 받은 사원의 사원번호, 이름 , 월급여 조회
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC; 		-- SAL 대신에 3 넣어도 됨.

SELECT EMPNO, ENAME 		-- 부서 번호가 10인 사람 중에 최대 급여를 받느 사람
FROM EMP					-- 동일한 급여를 받는 사원의 사원번호, 이름을 조회
WHERE SAL = (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 10);
